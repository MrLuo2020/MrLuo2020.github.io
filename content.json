{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://MrLuo2020.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"subscribe","date":"2021-04-25T05:42:59.844Z","updated":"2021-01-13T00:37:15.250Z","comments":true,"path":"2021/04/25/subscribe/","link":"","permalink":"https://mrluo2020.github.io/2021/04/25/subscribe/","excerpt":"","text":"发布订阅模式和观察者模式区别 在发布订阅模式里，发布者，并不会直接通知订阅者，换句话说，发布者Publisher和订阅者Subscriber，彼此互不相识。他们通过Broker来传递消息。发布订阅模式里，发布者和订阅者，不是松耦合，而是完全解耦的。 观察者模式则是松耦合(loosely coupled)的。Observer和Observable是相互感知的。 结构上的区别： 观察者模式只有2种角色Observer和Observable，而发布订阅模式则是Publisher、Broker和Subscriber。 逻辑解构上: 观察者模式是松耦合的，而发布订阅模式则是完全解耦的。 使用场景上: 观察者模式适用于单应用，而发布订阅使用于跨应用的场景。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function PubSub() &#123; this.handlers &#x3D; &#123;&#125;;&#125;PubSub.prototype &#x3D; &#123; &#x2F;&#x2F; 订阅事件 on: function (eventType, handler) &#123; var self &#x3D; this; if (!(eventType in self.handlers)) &#123;&#x2F;&#x2F; 如果事件不在回调集合里 self.handlers[eventType] &#x3D; []; &#125; self.handlers[eventType].push(handler);&#x2F;&#x2F; 加入回调函数 return this; &#125;, &#x2F;&#x2F; 触发事件(发布事件) emit: function (eventType) &#123; var self &#x3D; this; var handlerArgs &#x3D; Array.prototype.slice.call(arguments, 1); for (var i &#x3D; 0; i &lt; self.handlers[eventType].length; i++) &#123; self.handlers[eventType][i].apply(self, handlerArgs); &#125; return self; &#125;, &#x2F;&#x2F; 删除订阅事件 off: function (eventType, handler) &#123; var currentEvent &#x3D; this.handlers[eventType]; var len &#x3D; 0; if (currentEvent) &#123; len &#x3D; currentEvent.length; for (var i &#x3D; len - 1; i &gt;&#x3D; 0; i--) &#123; if (currentEvent[i] &#x3D;&#x3D;&#x3D; handler) &#123; currentEvent.splice(i, 1); &#125; &#125; &#125; return this; &#125;&#125;;var pubsub &#x3D; new PubSub();var callback &#x3D; function (data) &#123; console.log(&#39;cb:&#39;,data);&#125;;&#x2F;&#x2F;订阅事件Apubsub.on(&#39;A&#39;, function (data) &#123; console.log(1 + data);&#125;);pubsub.on(&#39;A&#39;, function (data) &#123; console.log(2 + data);&#125;);pubsub.on(&#39;A&#39;, callback);&#x2F;&#x2F;触发事件Apubsub.emit(&#39;A&#39;, &#39;我是参数&#39;);&#x2F;&#x2F;删除事件A的订阅源callbackpubsub.off(&#39;A&#39;, callback);pubsub.emit(&#39;A&#39;, &#39;我是第二次调用的参数&#39;); 结果： 123451我是参数2我是参数cb: 我是参数1我是第二次调用的参数2我是第二次调用的参数","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-04-25T05:38:34.622Z","updated":"2021-04-25T05:38:34.622Z","comments":true,"path":"2021/04/25/hello-world/","link":"","permalink":"https://mrluo2020.github.io/2021/04/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}